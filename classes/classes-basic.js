'use strict';

// для создания нового класса используется ключевое слово class, после которого указывается имя нового класса (принято писать с большой буквы)
// тело класса заключатеся в фигурные скобки
// класс - это форма или шаблон, на основе которого можно создавать новые объекты с определенными свойства и методами
// class - это функция, которая создает объекты
// новый экземпляр объекта, созданный на основе имеющегося класса, создается с помощью ключевого слова new и вызова функции класса

// конструктор - это особый метод класса, который вызывается при создании объекта, то есть в момент использования ключевого слова new
// конструктор создает свойства и подготавливает объект к использованию (инициализирует)
// в одном классе может быть только один конструктор
// если указано больше одного конструктора, возникнет сообщение об ошибке
// если конструктор не указан вовсе, javascript сам добавит в класс пустой конструктор
// конструктор в теле класса объявляется с помощью ключевого слова constructor

// свойства класса - это характеристики будущего объекта
// свойства указываются в конструкторе, благодаря чему каждый объект этого класса будет иметь данные свойства
// свойства создаются с отсылкой на объект с помощью ключевого слова this
// свойства указываются только внутри конструктора, иначе созданный по шаблону объект не будет содержать это свойство

// методы указываются за пределами конструктора
// между методами в классах не ставятся запятые

// Статические свойства - это свойства, которые принадлежат самому классу, а не объектам, которые созданы на его основе
// Статические свойства могут использоваться для хранения вспомогательной информации
// При этом статическое свойство нельзя объявить внутри самого класса
// Объявление статического свойства пишется после объявления класса, через точку от имени класса

// Статические методы - это методы, которые принадлежат самому классу, а не объектам, созданным на его основе
// Статические методы используют для создания вспомогательных функций
// Статические методы объявляются внутри класса с помощью ключевого слова static

// Также в классах можно создавать геттеры и сеттеры, которые внутри класса выглядят и ведут себя как методы, а снаружи класса выглядят и ведут себя как свойства
// С помощью геттеров и сеттеров можно получить доступ и присвоить значения свойствам этого класса

// Геттер объявляется внутри объекта с помощью ключевого слова get, его синтаксис аналогичен методам
// Геттер связывает свойство объекта с функцией, которая будет вызываться при обращении к этому свойству

// Названия геттеров и сеттеров не должны совпадать с именами основных свойств объекта
// Геттеры и сеттеры используются в паре, новая пара для каждого свойства

// Сеттер принимает параметр, который можно присвоить свойству, предварительно проверив этот параметр
// Обычно параметр, который принимает сеттер, называют value

// Свойства и методы в классах не делятся на личные и публичные, они все являются публичными
// Условно личные свойства и методы именуют, начиная с _. От переименования свойство не перестает быть публичным, но другие разработчики будут понимать, что его не предполагалось использовать как публичное

// У классов в ES6, также как у объектов, имена методов и свойств могут вычисляться динамически с помощью квадратных скобок
class Task {  
  constructor(title = Task.getDefaultTitle()) {
    this.title = title;
    this._done = false;
    Task.count += 1;
    console.log('Создание задачи');
  }
  
  get done() {
    return this._done === true ? 'Готово' : 'Не завершено';
  }
  
  set done(value) {
    if (value !== undefined && typeof value === 'boolean') {
      this._done = value;
    } else {
      console.error('This is a mistake');
    }
  }
  
  complete() {
    this.done = true;
    console.log(`Task "${this.title}" is complete`);
  }
  
  static getDefaultTitle() {
    return 'This is a default title';
  }
}

Task.count = 0;

let task = new Task();
let task2 = new Task('Second task');

console.log(task instanceof Task);
console.log(task.title);
console.log(Task.count);

task2.complete();
